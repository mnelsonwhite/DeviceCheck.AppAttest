using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics.CodeAnalysis;

namespace DeviceCheck.AppAttest.Cbor;

[Generator]
public class CborDeserializerContextGenerator: ISourceGenerator
{
	public CborDeserializerContextGenerator()
	{
	}

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
        {
            return;
        }

        foreach (var c in syntaxReceiver.Classes)
        {
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using DeviceCheck.AppAttest.Cbor;");
            builder.AppendLine("using System.Diagnostics.CodeAnalysis;");
            builder.AppendLine();
            builder.AppendLine($"namespace {c.namespaceName} {{");
            builder.AppendLine($"\t{c.modifiers} class {c.className}: {nameof(ICborSerializerContext)} {{");
            builder.AppendLine($"\t\tpublic Type {nameof(ICborSerializerContext.GetKeyType)}() => {c.keyType};");

            builder.AppendLine();
            builder.AppendLine($"\t\tpublic void {nameof(ICborSerializerContext.SetProperty)}(object property, object? value, object instance)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (_setters.TryGetValue(property, out var setter))");
            builder.AppendLine("\t\t\t{");
            builder.AppendLine($"\t\t\t\tsetter.setDelegate(value, ({c.className}) instance);");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");
            builder.AppendLine();

            builder.AppendLine($"\t\tpublic bool {nameof(ICborSerializerContext.TryGetPropertyType)}(object property, [NotNullWhen(returnValue:true)] out Type? type)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (_setters.TryGetValue(property, out var setter))");
            builder.AppendLine("\t\t\t{");
            builder.AppendLine("\t\t\t\ttype = setter.type;");
            builder.AppendLine("\t\t\t\treturn true;");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t\t");
            builder.AppendLine("\t\t\ttype = default;");
            builder.AppendLine("\t\t\treturn false;");
            builder.AppendLine("\t\t}");
            builder.AppendLine();

            builder.AppendLine($"\t\tpublic Dictionary<object, (Type type, Action<object?,{c.className}> setDelegate)> GetSetters() => _setters;");
            builder.AppendLine($"\t\tprivate static readonly Dictionary<object,(Type type, Action<object?,{c.className}> setDelegate)> _setters");
            builder.AppendLine($"\t\t\t= new Dictionary<object, (Type type, Action<object?,{c.className}> setDelegate)>");
            builder.AppendLine("\t\t{");

            if (syntaxReceiver.Props.TryGetValue($"{c.namespaceName}.{c.className}", out var props))
            {
                foreach(var prop in props)
                {
                    builder.AppendLine("\t\t\t{");
                    builder.AppendLine($"\t\t\t\t{prop.keyValue},");
                    builder.AppendLine("\t\t\t\t(");
                    builder.AppendLine($"\t\t\t\t\ttype: typeof({prop.propertyType}),");
                    builder.AppendLine("\t\t\t\t\tsetDelegate: (v,o) => {");
                    builder.AppendLine($"\t\t\t\t\t\tif (v is {prop.propertyType} p) {{");
                    builder.AppendLine($"\t\t\t\t\t\t\to.{prop.propertyName} = p;");
                    builder.AppendLine("\t\t\t\t\t\t}");
                    builder.AppendLine("\t\t\t\t\t}");
                    builder.AppendLine("\t\t\t\t)");
                    builder.AppendLine("\t\t\t},");
                }
            }

            builder.AppendLine("\t\t};");
            builder.AppendLine("\t}");
            builder.AppendLine("}");
            builder.AppendLine("#nullable disable");

            context.AddSource($"{c.className}.g.cs", builder.ToString());
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }
}

class SyntaxReceiver : ISyntaxReceiver
{
    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (!syntaxNode.TryGetNamespaceName(out var namespaceName)
            || !syntaxNode.TryGetParent<ClassDeclarationSyntax>(out var classSyntax)
            || !classSyntax.Modifiers.Any(v => v is SyntaxToken st && st.Text == "partial"))
        {
            return;
        }

        var className = classSyntax.Identifier.Text;
        var fullClassName = $"{namespaceName}.{className}";

        if (syntaxNode is AttributeSyntax {
                Name: IdentifierNameSyntax { Identifier.Text: "CborMap"}
            } mapAttr
        ) {
            var keyType = (mapAttr.ArgumentList?.Arguments.FirstOrDefault()?.Expression as LiteralExpressionSyntax)?.Token.ValueText
                ?? "typeof(string)";

            var modifiers = String.Join(" ", classSyntax.Modifiers.Select(v => v.Text));
            Classes.Add(new TargetClass(className, namespaceName, keyType, modifiers));
        }

        if (syntaxNode is AttributeSyntax {
                Name: IdentifierNameSyntax { Identifier.Text: "CborProperty" }
            } propAttr
            && propAttr.TryGetParent<PropertyDeclarationSyntax>(out var propSyntax)
        ) {
            if (!Props.ContainsKey(fullClassName))
            {
                Props[fullClassName] = new List<TargetProp>();
            }

            var keyValue = (propAttr.ArgumentList?.Arguments.FirstOrDefault()?.Expression as LiteralExpressionSyntax)?.Token.ToString()
            ?? $"\"{propSyntax.Identifier.Text}\"";

            var typeValue = propSyntax.Type is NullableTypeSyntax nt ? nt.ElementType.ToString() : propSyntax.Type.ToString();

            Props[fullClassName].Add(new TargetProp(
                keyValue,
                typeValue,
                propSyntax.Identifier.Text
            ));
        }
    }

    public record TargetClass(string className, string namespaceName, string keyType, string modifiers);
    public record TargetProp(string keyValue, string propertyType, string propertyName);
    public readonly List<TargetClass> Classes = new List<TargetClass>();
    public readonly Dictionary<string, List<TargetProp>> Props = new Dictionary<string, List<TargetProp>>();
}

static class SyntaxNodeExtensions
{
    public static bool TryGetParent<T>(
        this SyntaxNode node,
        [NotNullWhen(returnValue: true)] out T? parent
    ) where T: SyntaxNode
    {
        var nparent = node.Parent;
        while (nparent is not null)
        {
            if (nparent is T t) {
                parent = t;
                return true;
            }

            nparent = nparent.Parent;
        }

        parent = default;
        return false;
    }

    public static bool TryGetNamespaceName(
        this SyntaxNode node,
        [NotNullWhen(returnValue:true)] out string? namespaceName)
    {
        if(node.TryGetParent<NamespaceDeclarationSyntax>(out var namespaceSyntax))
        {
            namespaceName = namespaceSyntax.Name.ToString();
            return true;
        }

        if(node.TryGetParent<FileScopedNamespaceDeclarationSyntax>(out var fileScopedNamespaceSyntax))
        {
            namespaceName = fileScopedNamespaceSyntax.Name.ToString();
            return true;
        }

        namespaceName = default;
        return false;
    }
}